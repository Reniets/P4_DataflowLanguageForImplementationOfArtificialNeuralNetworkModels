import AST.*;
import AST.Nodes.AbstractNodes.*;
import AST.Nodes.AbstractNodes.Nodes.*;
import AST.Nodes.AbstractNodes.Nodes.AbstractNodes.*;
import AST.Nodes.AbstractNodes.Nodes.AbstractNodes.NumberedNodes.*;
import AST.Nodes.AbstractNodes.Nodes.AbstractNodes.NumberedNodes.NamedNodes.*;
import AST.Nodes.NodeClasses.NamedNodes.*;
import AST.Nodes.NodeClasses.NamedNodes.NamedIdNodes.*;
import AST.Nodes.SpecialNodes.*;
import AST.Enums.*;
import AST.TreeWalks.*;
import AST.TreeWalks.Exceptions.*;
import java.io.*;
import java_cup.runtime.*;
import java.util.*;

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

parser code {:
        private AbstractNode rootNode;

        public AbstractNode createRootNode() {
            this.rootNode = new RootNode();
            return this.rootNode;
        }

        public AbstractNode getRootNode() {
            return this.rootNode;
        }

        /*
        public void syntax_error(Symbol cur_token){
            if (!MainParse.isTest) {
                super.syntax_error(cur_token);
            }
        }
        */

        // ##### IMPORTANT IMPLEMENTATION - THE "ScannerException" CLASS IS USED IN TESTING!!! #####
        public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
            try {
                // Call original method implementation
                super.unrecovered_syntax_error(cur_token);
            } catch (Exception e) {
                // Rethrow exception as a ScannerException instead of a generic "Exception", to identify in testing.
                throw new AutoGen.ScannerException(e);
            }
        }

        public static void newScope(){
    	    typenames.push(new HashSet<String>());
        }

        public static void deleteScope(){
    	    typenames.pop();
        }

        public static boolean lookupType(String name){
            for (HashSet<String> scope: typenames)
                if (scope.contains(name)) return true;
            return false;
        }

        public static void addType(String name){
    	    typenames.peek().add(name);
        }

        public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();

        public Parser(Lexer lex, ComplexSymbolFactory sf) {
    	    super(lex,sf);
        }

:};

/* separators */
terminal Symbol COMMA, SEMICOLON, LPAR, RPAR, LCURLY, RCURLY, ASSIGN, CONNECTION, LSQR, RSQR, DOT;

/* keywords */
terminal Symbol BLOCK, BLUEPRINT, BUILD, DRAW, SOURCE, OPERATION, CHANNELIN, CHANNELOUT, PROCEDURE, THIS, SIZE;

/* others */
terminal String ID;
terminal Double NUMCONST;
terminal Integer INTCONST;

non terminal AbstractNode block, blocks, prog, type, buildtype, bluetype, channel, blueparam, blueparams,
             blueextparams, statement, declaration, declstoporstay, optidstatement, optlparstatement, optthisstatement,
             elementrest, chain, elementliststart, procedurecall, element, groupcon, dotid, elementpar, chainext, parchain,
             elementlist, elementlistext, elementext, pparams, pextparams, parclosestatement, builddeclaration,
             buildelement, buildelementpar, sizepar, inchanneldeclaration, outchanneldeclaration, inoutchanneldeclaration,
             nodedeclaration, nonnodedeclaration, nodeelement, nonnodeelement, nodeelementpar, blueprintassign, sizeassign,
             channelassign, buildassign, blueprintassignopt, sizeassignopt, channelassignopt, builddecla, channelelementspar, channelelement, idpar;

non terminal AbstractNode blueprint, content, procedures, definition, channeldeclarations;

non terminal SizeNode sizeconst;
// TODO: Add precedence and associativity

/* The grammar rules */
start with prog;

prog                    ::= blocks:bs
                        {:
                            AbstractNode prog = createRootNode().adoptChildren(bs);

                            //System.out.println("\nAST\n");
                            //prog.walkTree(new PrintTree(System.out));
                        :}
                        ;

// BLOCK
block 			        ::= BLOCK ID:ident LCURLY definition:def RCURLY
                        {:
                            RESULT = new BlockNode(ident).adoptChildren(def);
                        :}
                        ;

blocks                  ::= block:b
                        {: RESULT = b; :}
                        | block:b blocks:bs
                        {: RESULT = b.makeSibling(bs); :}
                        ;

definition 		        ::= channeldeclarations:gds blueprint:bp procedures:pds
                        {:
                            RESULT = (pds != null) ? gds.makeSibling(bp).makeSibling(pds) : gds.makeSibling(bp);
                        :}
                        ;

// GENERAL
type				    ::= buildtype:type
                        {: RESULT = type; :}
					    | bluetype:type
					    {: RESULT = type; :}
					    | channel:channel
					    {: RESULT = channel; :}
                        ;
buildtype			    ::= BLOCK
                        {: RESULT = new BlockTypeNode("NoIden"); :}
					    | OPERATION
					    {: RESULT = new OperationTypeNode("NoIden"); :}
					    | SOURCE
					    {: RESULT = new SourceTypeNode("NoIden"); :}
                        ;
// CHANNELS
channeldeclarations        ::= inchanneldeclaration:ind outchanneldeclaration:outd inoutchanneldeclaration:inoutd
                        {:
                            RESULT = new ChannelDeclarationsNode().adoptChildren(ind, outd, inoutd);
                        :}
                        ;
inchanneldeclaration       ::= CHANNELIN ID:id SEMICOLON inchanneldeclaration:ind
                        {:
                        AbstractNode channelNode = new InChannelNode(id);
                        RESULT = (ind!=null) ? channelNode.makeSibling(ind) : channelNode;
                        :}
                        |
                        ;
outchanneldeclaration      ::= CHANNELOUT ID:id SEMICOLON
                        {: RESULT = new OutChannelNode(id); :}
                        ;
inoutchanneldeclaration    ::= channel:g ID:id SEMICOLON inoutchanneldeclaration:gd
                        {:
                           AbstractNode channelNode = ((NamedIdNode) g).setId(id);
                           RESULT = (gd != null) ? channelNode.makeSibling(gd) :  channelNode; :}
					    |
					    ;
channel				    ::= CHANNELIN
                        {: RESULT = new InChannelNode("NoIden"); :}
					    | CHANNELOUT
					    {: RESULT = new OutChannelNode("NoIden"); :}
                        ;
// BLUEPRINT
blueprint			    ::= BLUEPRINT LPAR blueparams:bps RPAR LCURLY content:cnt RCURLY
                        {:
                           AbstractNode blueprintNode = new BlueprintNode();
                           if (bps != null) {
                                blueprintNode.adoptChildren(bps);
                           }
                           if (cnt != null) {
                               blueprintNode.adoptChildren(cnt);
                           }
                           RESULT = blueprintNode;
                        :}
                        ;
blueparams		        ::= blueparam:bp
                        {: RESULT = ((new ParamsNode()).adoptChildren(bp)); :}
					    |
                        ;
blueparam			    ::= bluetype:bt ID:id blueextparams:btx
                        {:
                           AbstractNode typeNode = ((NamedIdNode) bt).setId(id);
                           RESULT = (btx != null) ? (typeNode.makeSibling(btx)) : (typeNode);
                        :}
                        ;
blueextparams		    ::= COMMA blueparam:bp
                        {: RESULT = bp;:}
                        |
                        ;

bluetype 			    ::= BLUEPRINT
                        {: RESULT = new BlueprintTypeNode("NoIden"); :}
                        | SIZE
                        {: RESULT = new SizeTypeNode("NoIden"); :}
                        ;
// CONTENT
content			        ::= statement:st SEMICOLON content:ct
                        {: // TODO: Fix this future me. (Expand to if else chain)
                           RESULT = (st != null && ct != null) ? st.makeSibling(ct) : ((st != null) ? (st) : (ct)); :}
					    |
                        ;
statement			    ::= declaration:decl
                        {: RESULT = decl; :}
					    | ID:id optidstatement:st
					    {:
					        // Chain
					        if (st instanceof StorageNode) {
					            String storageName = st.getName();

					            if ("Chain".equals(storageName)) {
					                AbstractNode dotId = st.getNodes()[0];
					                AbstractNode chainNode = st.getNodes()[1];
                                    AbstractNode idSelector = new SelectorNode(id);

                                    idSelector.adoptChildren(dotId);

                                    RESULT = chainNode.adoptAsFirstChild(idSelector);
					            } else if ("Assign".equals(storageName)) {
					                AbstractNode assignNode = st.getNodes()[0].adoptAsFirstChild(new SelectorNode(id));
					                AbstractNode chainNode = st.getNodes()[1];

					                RESULT = (chainNode != null) ? chainNode.adoptAsFirstChild(assignNode) : assignNode;

					            } else {
					                // Security check, should never happen - But helps with development.
					                throw new RuntimeException("No such name case");
					            }
					        } else {
					            RESULT = st.adoptChildren(new SelectorNode(id));
					        }
					    :}
					    | LPAR optlparstatement:statement
					    {: RESULT = statement; :}
					    | THIS DOT ID:id optthisstatement:st
					    {: RESULT = st.adoptAsFirstChild(new SelectorNode("this").adoptChildren(new SelectorNode(id))); :}
					    | builddeclaration:bdecl chain:chain
					    {: RESULT = chain.adoptAsFirstChild(bdecl); :}
					    |
                        ;
procedurecall		    ::= LPAR elementliststart:paras RPAR
                        {:
                            AbstractNode procedure = new ProcedureCallNode();

                            if (paras != null) {
                                procedure.adoptChildren((new ParamsNode()).adoptChildren(paras));
                            }

                            RESULT = procedure;
                        :}
                        ;
// OPTION SELECT FOR STATEMENTS
optlparstatement	    ::= LPAR element:elem RPAR groupcon:groupcon
					    {:
					        // Group connection
                            AbstractNode group = groupcon.getNodes()[0];
                            AbstractNode chain = groupcon.getNodes()[1];

                            group.adoptAsFirstChild(elem);

                            RESULT = chain;
					     :}
					    | element:elem parclosestatement:chainorgroup
					    {:
					        // Group connection
    					    if (chainorgroup instanceof StorageNode) {
    					        AbstractNode group = chainorgroup.getNodes()[0];
                                AbstractNode chain = chainorgroup.getNodes()[1];

    					        group.adoptAsFirstChild(elem);

    					        RESULT = chain;
    					    } else {
    					        RESULT = chainorgroup.adoptAsFirstChild(elem);
    					    }
					     :}
                        ;
parclosestatement	    ::= parchain:chain
                        {: RESULT = chain; :}
					    | groupcon:group
					    {: RESULT = group; :}
                        ;
optidstatement	        ::= dotid:did chain:c
                        {: RESULT = new StorageNode("Chain", did, c); :}
					    | procedurecall:pdc
					    {: RESULT = pdc; :}
					    | ASSIGN elementpar:elem declstoporstay:chain
					    {: RESULT = new StorageNode("Assign", new AssignNode().adoptChildren(elem), chain); :}
                        ;
optthisstatement	    ::= procedurecall:pdc
                        {: RESULT = pdc; :}
                        | chain:chain
                        {: RESULT = chain; :}
                        ;
// COLLECTIVE STATEMENTS
chain				    ::= CONNECTION nodeelementpar:elem chainext:next
                        {:
                            RESULT = (next != null) ? next.adoptAsFirstChild(elem) : new ChainNode().adoptChildren(elem);
                         :}
                        ;
parchain			    ::= RPAR chain:chain
                        {: RESULT = chain; :}
                        ;
chainext			    ::= chain:chain
                        {: RESULT = chain; :}
					    |
                        ;
groupcon			    ::= elementlist:elemlist RPAR CONNECTION elementpar:elem chainext:chain
                        {:
                            AbstractNode group = new GroupNode().adoptChildren(elemlist);

                            if (chain != null) {
                                group.makeSibling(elem);
                                chain.adoptAsFirstChild(group);
                                RESULT = new StorageNode(group, chain);
                            } else {
                                AbstractNode conn = new ChainNode().adoptChildren(group, elem);
                                RESULT = new StorageNode(group, conn);
                            }
                         :}
                        ;
// ELEMENTS
element			        ::= elementrest:elem
                        {: RESULT = elem; :}
					    | nodeelement:elem
					    {: RESULT = elem; :}
					    | nonnodeelement:elem
					    {: RESULT = elem; :}
					    | nonnodedeclaration:elem
					    {: RESULT = elem; :}
                        ;

nodeelement             ::= nodedeclaration:elem
                        {: RESULT = elem; :}
                        | ID:id dotid:did
                        {: RESULT = (new SelectorNode(id)).adoptChildren(did); :}
                        | THIS DOT ID:id
                        {: RESULT = new SelectorNode("this").adoptChildren(new SelectorNode(id)); :}
                        | builddeclaration:build
                        {: RESULT = build; :}
                        ;

nonnodeelement          ::= DRAW ID:id
                        {: RESULT = new DrawNode(id); :}
                        | sizeconst:sc
                        {: RESULT = sc; :}
                        ;

buildelement		    ::= builddeclaration:build
                        {: RESULT = build; :}
					    | ID:id
					    {: RESULT = new SelectorNode(id); :}
					    | LPAR buildelementpar:belem
					    {: RESULT = belem; :}
					    ;
buildelementpar		    ::= builddeclaration:build RPAR
                        {: RESULT = build; :}
					    | ID:id RPAR
                        {: RESULT = new SelectorNode(id); :}
					    ;
dotid				    ::= DOT ID:id
                        {: RESULT = new SelectorNode(id); :}
					    |
                        ;
elementpar		        ::= LPAR element:elem RPAR
                        {: RESULT = elem; :}
					    | element:elem
					    {: RESULT = elem; :}
                        ;

nodeelementpar          ::= LPAR nodeelement:elem RPAR
                        {: RESULT = elem; :}
                        | nodeelement:elem
                        {: RESULT = elem; :}
                        ;

sizepar                 ::= sizeconst:size
                        {: RESULT = size; :}
                        | LPAR sizeconst:size RPAR
                        {: RESULT = size; :}
                        ;

sizeconst               ::= LSQR INTCONST:n1 COMMA INTCONST:n2 RSQR
                        {: RESULT = new SizeNode(n1, n2); :}
                        ;

channelelementspar         ::= LPAR channelelement:elem RPAR
                        {: RESULT = elem; :}
                        | channelelement:elem
                        {: RESULT = elem; :}
                        ;

channelelement             ::= THIS DOT ID:id
                        {: RESULT = new SelectorNode("this").adoptChildren(new SelectorNode(id)); :}
                        | ID:id dotid:dotid
                        {: RESULT = new SelectorNode(id).adoptChildren(dotid); :}
                        ;

idpar                   ::= LPAR ID:id RPAR
                        {: RESULT = new SelectorNode(id); :}
                        | ID:id
                        {: RESULT = new SelectorNode(id); :}
                        ;

// DECLARATION ELEMENT
nodedeclaration         ::= buildtype:type ID:id buildassign:assign
                        {: RESULT = assign.adoptAsFirstChild(((NamedIdNode) type).setId(id)); :}
                        ;

nonnodedeclaration      ::= BLUEPRINT ID:id blueprintassign:assign
                        {: RESULT = assign.adoptAsFirstChild(new BlueprintTypeNode(id)); :}
                        | SIZE ID:id sizeassign:assign
                        {: RESULT = assign.adoptAsFirstChild(new SizeTypeNode(id)); :}
                        | channel:type ID:id channelassign:assign
                        {: RESULT = assign.adoptAsFirstChild(((NamedIdNode) type).setId(id)); :}
                        ;

declaration             ::= BLUEPRINT ID:id blueprintassignopt:assign
                        {:
                            AbstractNode typeNode = new BlueprintTypeNode(id);
                            RESULT = (assign != null) ? assign.adoptAsFirstChild(typeNode) : typeNode;
                        :}
                        | SIZE ID:id sizeassignopt:assign
                        {:
                            AbstractNode typeNode = new SizeTypeNode(id);
                            RESULT = (assign != null) ? assign.adoptAsFirstChild(typeNode) : typeNode;
                        :}
                        | channel:channel ID:id channelassignopt:assign
                        {:
                            AbstractNode typeNode = (((NamedIdNode) channel).setId(id));
                            RESULT = (assign != null) ? assign.adoptAsFirstChild(typeNode) : typeNode;
                        :}
                        | buildtype:type ID:id builddecla:decla
                        {:
                            AbstractNode typeNode = (((NamedIdNode) type).setId(id));

                            if (decla != null) {
                                AbstractNode assign = decla.getNodes()[0];
                                AbstractNode chain = decla.getNodes()[1];

                                assign.adoptAsFirstChild(typeNode);

                                if (chain != null) {
                                    chain.adoptAsFirstChild(assign);

                                    RESULT = chain;
                                } else {
                                    RESULT = assign;
                                }
                            } else {
                                RESULT = typeNode;
                            }
                        :}
                        ;

builddecla              ::= buildassign:assign declstoporstay:chain
                        {: RESULT = new StorageNode(assign, chain); :}
                        |
                        ;

blueprintassign         ::= ASSIGN DRAW idpar:elem
                        {: RESULT = new AssignNode().adoptChildren(new DrawNode(((NamedIdNode) elem).getId())); :}
                        ;
sizeassign              ::= ASSIGN sizepar:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        | ASSIGN idpar:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        ;
channelassign           ::= ASSIGN channelelementspar:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        ;
buildassign             ::= ASSIGN buildelement:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        ;
blueprintassignopt      ::= blueprintassign:assign
                        {: RESULT = assign; :}
                        |
                        ;
sizeassignopt           ::= sizeassign:assign
                        {: RESULT = assign; :}
                        |
                        ;
channelassignopt           ::= channelassign:assign
                        {: RESULT = assign; :}
                        |
                        ;

builddeclaration	    ::= BUILD ID:id LPAR elementliststart:elemlist RPAR
                        {:
                            AbstractNode buildNode = new BuildNode(id);
                            RESULT = (elemlist != null) ? buildNode.adoptChildren((new ParamsNode()).adoptChildren(elemlist)) : buildNode;
                        :}
                        ;
declstoporstay		    ::= chain:chain
                        {: RESULT = chain; :}
					    |
                        ;
// ELEMENTLIST
elementliststart	    ::= elementpar:elem elementlistext:next
                        {: RESULT = (next != null) ? elem.makeSibling(next) : elem; :}
					    |
                        ;
elementlist		        ::= elementext:elem elementlistext:next
                        {: RESULT = (next != null) ? elem.makeSibling(next) : elem; :}
                        ;
elementlistext	        ::= elementlist:elemlist
                        {: RESULT = elemlist; :}
					    |
                        ;
elementext		        ::= COMMA elementpar:elem
                        {: RESULT = elem; :}
                        ;

// PROCEDURES
procedures		        ::= PROCEDURE ID:id LPAR pparams:params RPAR LCURLY content:ct RCURLY procedures:next
                        {:
                            AbstractNode procedure = new ProcedureNode(id);
                            if (params != null) {
                                procedure.adoptChildren(new ParamsNode().adoptChildren(params));
                            }
                            procedure.adoptChildren(ct);

                            RESULT = (next != null) ? procedure.makeSibling(next) : procedure;
                        :}
					    |
                        ;
pparams			        ::= type:type ID:id pextparams:next
                        {:
                            AbstractNode param = ((NamedIdNode) type).setId(id);

                            RESULT = (next != null) ? param.makeSibling(next) : param;
                         :}
					    |
                        ;
pextparams		        ::= COMMA pparams:par
                        {: RESULT = par; :}
					    |
                        ;