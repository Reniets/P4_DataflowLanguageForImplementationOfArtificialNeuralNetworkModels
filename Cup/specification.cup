import AST.*;
import java.io.*;
import java_cup.runtime.*;
import java.util.*;

import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

action code {:
    HashMap root = new HashMap();
    HashMap root = new HashMap();
:};

parser code {:

        /*
        public void syntax_error(Symbol cur_token){
            if (!MainParse.isTest) {
                super.syntax_error(cur_token);
            }
        }
        */

        // ##### IMPORTANT IMPLEMENTATION - THE "ScannerException" CLASS IS USED IN TESTING!!! #####
        public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
            try {
                // Call original method implementation
                super.unrecovered_syntax_error(cur_token);
            } catch (Exception e) {
                // Rethrow exception as a ScannerException instead of a generic "Exception", to identify in testing.
                throw new AutoGen.ScannerException(e);
            }
        }

        public static void newScope(){
    	    typenames.push(new HashSet<String>());
        }

        public static void deleteScope(){
    	    typenames.pop();
        }

        public static boolean lookupType(String name){
    	for (HashSet<String> scope: typenames)
    	    if (scope.contains(name)) return true;
    	return false;
        }

        public static void addType(String name){
    	typenames.peek().add(name);
        }

        public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();

        public Parser(Lexer lex, ComplexSymbolFactory sf) {
    	    super(lex,sf);
        }

        class TemporaryNode extends AbstractNode {

             private String s;

             public TemporaryNode(String s) {
               this.s = s;
             }

             public String getName() { return s; }

       }

      //public AbstractNode makeNode(Symbol s) { return new TemporaryNode(symString.symToString[s.sym]); }
      public AbstractNode makeNode(String s) { return new TemporaryNode(s);   }

      //public AbstractNode makeNode(Integer i) { return new IntegerNode(i);   }

:};

// TODO:  Fix dot and add size

/* separators */
terminal Symbol COMMA, SEMICOLON, LPAR, RPAR, LCURLY, RCURLY, ASSIGN, CONNECTION, LSQR, RSQR, DOT;

/* keywords */
terminal Symbol BLOCK, BLUEPRINT, BUILD, DRAW, SOURCE, OPERATION, GATEIN, GATEOUT, PROCEDURE, THIS, SIZE;

/* others */
terminal String ID;
terminal Double NUMCONST;
terminal Integer INTCONST;

non terminal AbstractNode block, blocks, prog, type, buildtype, bluetype, gate, blueparam, blueparams,
             blueextparams, statement, declaration, declstoporstay, optidstatement, optlparstatement, optthisstatement,
             elementrest, chain, elementliststart, procedurecall, element, groupcon, dotid, elementpar, chainext, parchain,
             elementlist, elementlistext, elementext, pparams, pextparams, parclosestatement, builddeclaration,
             buildelement, buildelementpar, sizepar, ingatedeclaration, outgatedeclaration, inoutgatedeclaration,
             nodedeclaration, nonnodedeclaration, nodeelement, nonnodeelement, nodeelementpar, blueprintassign, sizeassign,
             gateassign, buildassign, blueprintassignopt, sizeassignopt, gateassignopt, builddecla, gateelementspar, gateelement, idpar;

non terminal AbstractNode blueprint, content, procedures, definition, gatedeclarations;

non terminal DoublePair sizeconst;
// TODO: Add precedence and associativity

/* The grammar rules */
start with prog;

prog                    ::= blocks:bs
                        {:
                            AbstractNode prog = makeNode("Program").adoptChildren(bs);

                            System.out.println("\nAST\n");
                            prog.walkTree(new PrintTree(System.out));
                        :}
                        ;

// BLOCK
block 			        ::= BLOCK ID:ident LCURLY definition:def RCURLY
                        {:
                            RESULT = new BlockNode(ident).adoptChildren(def);
                            root.put(ident, RESULT);
                        :}
                        ;

blocks                  ::= block:b
                        {: RESULT = b; :}
                        | block:b blocks:bs
                        {: RESULT = bs.makeSibling(b); :}
                        ;

definition 		        ::= gatedeclarations:gds blueprint:bp procedures:pds
                        {:
                            RESULT = (pds != null) ? gds.makeSibling(bp).makeSibling(pds) : gds.makeSibling(bp);
                            for (String block : root.keys()) {

                            }
                        :}
                        ;

// GENERAL
type				    ::= buildtype:type
                        {: RESULT = type; :}
					    | bluetype:type
					    {: RESULT = type; :}
					    | gate:gate
					    {: RESULT = gate; :}
                        ;
buildtype			    ::= BLOCK
                        {: RESULT = new BlockTypeNode("NoIden"); :}
					    | OPERATION
					    {: RESULT = new OperationTypeNode("NoIden"); :}
					    | SOURCE
					    {: RESULT = new SourceTypeNode("NoIden"); :}
                        ;
// GATES
gatedeclarations        ::= ingatedeclaration:ind outgatedeclaration:outd inoutgatedeclaration:inoutd
                        {:
                            if (ind != null) outd.makeSibling(ind);
                            if (inoutd != null) outd.makeSibling(inoutd);
                            RESULT = outd;
                        :}
                        ;
ingatedeclaration       ::= GATEIN ID:id SEMICOLON ingatedeclaration:ind
                        {: RESULT = (ind!=null) ? ind.makeSibling(new InGateNode(id)) : new InGateNode(id); :}
                        |
                        ;
outgatedeclaration      ::= GATEOUT ID:id SEMICOLON
                        {: RESULT = new OutGateNode(id); :}
                        ;
inoutgatedeclaration    ::= gate:g ID:id SEMICOLON inoutgatedeclaration:gd
                        {:
                           AbstractNode gateNode = ((IdNode) g).setId(id);
                           RESULT = (gd != null) ? gd.makeSibling(gateNode) :  gateNode; :}
					    |
					    ;
gate				    ::= GATEIN
                        {: RESULT = new InGateNode("NoIden"); :}
					    | GATEOUT
					    {: RESULT = new OutGateNode("NoIden"); :}
                        ;
// BLUEPRINT
blueprint			    ::= BLUEPRINT LPAR blueparams:bps RPAR LCURLY content:cnt RCURLY
                        {:
                           AbstractNode blueprintNode = new BlueprintNode();
                           if (bps != null) {
                                blueprintNode.adoptChildren(bps);
                           }
                           if (cnt != null) {
                               blueprintNode.adoptChildren(cnt);
                           }
                           RESULT = blueprintNode;
                        :}
                        ;
blueparams		        ::= blueparam:bp
                        {: RESULT = ((new ParamsNode()).adoptChildren(bp)); :}
					    |
                        ;
blueparam			    ::= bluetype:bt ID:id blueextparams:btx
                        {:
                           AbstractNode typeNode = ((IdNode) bt).setId(id);
                           RESULT = (btx != null) ? (btx.makeSibling(typeNode)) : (typeNode);
                        :}
                        ;
blueextparams		    ::= COMMA blueparam:bp
                        {: RESULT = bp;:}
                        |
                        ;
// TODO: Add when ready:
bluetype 			    ::= BLUEPRINT
                        {: RESULT = new BlueprintTypeNode("NoIden"); :}
                        | SIZE
                        {: RESULT = new SizeNode("NoIden"); :}
                        ;
// CONTENT
content			        ::= statement:st SEMICOLON content:ct
                        {: // TODO: Fix this future me. (Expand to if else chain)
                           RESULT = (st != null && ct != null) ? ct.makeSibling(st) : ((st != null) ? (st) : (ct)); :}
					    |
                        ;
statement			    ::= declaration:decl
                        {: RESULT = decl; :}
					    | ID:id optidstatement:st
					    {:
					        // Chain
					        if (st instanceof StorageNode) {
					            String storageName = st.getName();

					            if ("Chain".equals(storageName)) {
					                AbstractNode chainNode = st.getNodes()[1];
                                    AbstractNode idSelector = new SelectorNode(id);

                                    idSelector.adoptChildren(st.getNodes()[0]);

                                    RESULT = chainNode.adoptChildren(idSelector);
					            } else if ("Assign".equals(storageName)) {
					                AbstractNode assignNode = st.getNodes()[0].adoptChildren(new SelectorNode(id));
					                AbstractNode chainNode = st.getNodes()[1];

					                RESULT = (chainNode != null) ? chainNode.adoptChildren(assignNode) : assignNode;

					            } else {
					                // Security check, should never happen - But helps with development.
					                throw new RuntimeException("No such name case");
					            }
					        } else {
					            RESULT = st.adoptChildren(new SelectorNode(id));
					        }
					    :}
					    | LPAR optlparstatement:statement
					    {: RESULT = statement; :}
					    | THIS DOT ID:id optthisstatement:st
					    {: RESULT = st.adoptChildren(new SelectorNode("this").adoptChildren(new SelectorNode(id))); :}
					    | builddeclaration:bdecl chain:chain
					    {: RESULT = chain.adoptChildren(bdecl); :}
					    |
                        ;
procedurecall		    ::= LPAR elementliststart:paras RPAR
                        {:
                            AbstractNode procedure = new ProcedureCallNode();

                            if (paras != null) {
                                procedure.adoptChildren((new ParamsNode()).adoptChildren(paras));
                            }

                            RESULT = procedure;
                        :}
                        ;
// OPTION SELECT FOR STATEMENTS
optlparstatement	    ::= LPAR element:elem RPAR groupcon:groupcon
					    {:
					        // Group connection
                            AbstractNode group = groupcon.getNodes()[0];
                            AbstractNode chain = groupcon.getNodes()[1];

                            group.adoptChildren(elem);

                            RESULT = chain;
					     :}
					    | element:elem parclosestatement:chainorgroup
					    {:
					        // Group connection
    					    if (chainorgroup instanceof StorageNode) {
    					        AbstractNode group = chainorgroup.getNodes()[0];
                                AbstractNode chain = chainorgroup.getNodes()[1];

    					        group.adoptChildren(elem);

    					        RESULT = chain;
    					    } else {
    					        RESULT = chainorgroup.adoptChildren(elem);
    					    }
					     :}
                        ;
parclosestatement	    ::= parchain:chain
                        {: RESULT = chain; :}
					    | groupcon:group
					    {: RESULT = group; :}
                        ;
optidstatement	        ::= dotid:did chain:c
                        {: RESULT = new StorageNode("Chain", did, c); :}
					    | procedurecall:pdc
					    {: RESULT = pdc; :}
					    | ASSIGN elementpar:elem declstoporstay:chain
					    {: RESULT = new StorageNode("Assign", new AssignNode().adoptChildren(elem), chain); :}
                        ;
optthisstatement	    ::= procedurecall:pdc
                        {: RESULT = pdc; :}
                        | chain:chain
                        {: RESULT = chain; :}
                        ;
// COLLECTIVE STATEMENTS
chain				    ::= CONNECTION nodeelementpar:elem chainext:next
                        {:
                            RESULT = (next != null) ? next.adoptChildren(elem) : new ChainNode().adoptChildren(elem);
                         :}
                        ;
parchain			    ::= RPAR chain:chain
                        {: RESULT = chain; :}
                        ;
chainext			    ::= chain:chain
                        {: RESULT = chain; :}
					    |
                        ;
groupcon			    ::= elementlist:elemlist RPAR CONNECTION elementpar:elem chainext:chain
                        {:
                            AbstractNode group = new GroupNode().adoptChildren(elemlist);

                            if (chain != null) {
                                chain.adoptChildren(elem, group);
                                RESULT = new StorageNode(group, chain);
                            } else {
                                AbstractNode conn = new ChainNode().adoptChildren(elem, group);
                                RESULT = new StorageNode(group, conn);
                            }
                         :}
                        ;
// ELEMENTS
element			        ::= elementrest:elem
                        {: RESULT = elem; :}
					    | nodeelement:elem
					    {: RESULT = elem; :}
					    | nonnodeelement:elem
					    {: RESULT = elem; :}
					    | nonnodedeclaration:elem
					    {: RESULT = elem; :}
                        ;

nodeelement             ::= nodedeclaration:elem
                        {: RESULT = elem; :}
                        | ID:id dotid:did
                        {: RESULT = (new SelectorNode(id)).adoptChildren(did); :}
                        | THIS DOT ID:id
                        {: RESULT = new SelectorNode("this").adoptChildren(new SelectorNode(id)); :}
                        | builddeclaration:build
                        {: RESULT = build; :}
                        ;

nonnodeelement          ::= DRAW ID:id
                        {: RESULT = new DrawNode(id); :}
                        | sizeconst:sc
                        {: RESULT = sc; :}
                        ;

buildelement		    ::= builddeclaration:build
                        {: RESULT = build; :}
					    | ID:id
					    {: RESULT = new SelectorNode(id); :}
					    | LPAR buildelementpar:belem
					    {: RESULT = belem; :}
					    ;
buildelementpar		    ::= builddeclaration:build RPAR
                        {: RESULT = build; :}
					    | ID:id RPAR
                        {: RESULT = new SelectorNode(id); :}
					    ;
dotid				    ::= DOT ID:id
                        {: RESULT = new SelectorNode(id); :}
					    |
                        ;
elementpar		        ::= LPAR element:elem RPAR
                        {: RESULT = elem; :}
					    | element:elem
					    {: RESULT = elem; :}
                        ;

nodeelementpar          ::= LPAR nodeelement:elem RPAR
                        {: RESULT = elem; :}
                        | nodeelement:elem
                        {: RESULT = elem; :}
                        ;

sizepar                 ::= sizeconst:size
                        {: RESULT = size; :}
                        | LPAR sizeconst:size RPAR
                        {: RESULT = size; :}
                        ;

sizeconst               ::= LSQR INTCONST:n1 COMMA INTCONST:n2 RSQR
                        {: RESULT = new DoublePair(n1, n2); :}
                        ;

gateelementspar         ::= LPAR gateelement:elem RPAR
                        {: RESULT = elem; :}
                        | gateelement:elem
                        {: RESULT = elem; :}
                        ;

gateelement             ::= THIS DOT ID:id
                        {: RESULT = new SelectorNode("this").adoptChildren(new SelectorNode(id)); :}
                        | ID:id dotid:dotid
                        {: RESULT = new SelectorNode(id).adoptChildren(dotid); :}
                        ;

idpar                   ::= LPAR ID:id RPAR
                        {: RESULT = new SelectorNode(id); :}
                        | ID:id
                        {: RESULT = new SelectorNode(id); :}
                        ;

// DECLARATION ELEMENT
nodedeclaration         ::= buildtype:type ID:id buildassign:assign
                        {: RESULT = assign.adoptChildren(((IdNode) type).setId(id)); :}
                        ;

nonnodedeclaration      ::= BLUEPRINT ID:id blueprintassign:assign
                        {: RESULT = assign.adoptChildren(new BlueprintTypeNode(id)); :}
                        | SIZE ID:id sizeassign:assign
                        {: RESULT = assign.adoptChildren(new SizeNode(id)); :}
                        | gate:type ID:id gateassign:assign
                        {: RESULT = assign.adoptChildren(((IdNode) type).setId(id)); :}
                        ;

declaration             ::= BLUEPRINT ID:id blueprintassignopt:assign
                        {:
                            AbstractNode typeNode = new BlueprintTypeNode(id);
                            RESULT = (assign != null) ? assign.adoptChildren(typeNode) : typeNode;
                        :}
                        | SIZE ID:id sizeassignopt:assign
                        {:
                            AbstractNode typeNode = new SizeNode(id);
                            RESULT = (assign != null) ? assign.adoptChildren(typeNode) : typeNode;
                        :}
                        | gate:gate ID:id gateassignopt:assign
                        {:
                            AbstractNode typeNode = (((IdNode) gate).setId(id));
                            RESULT = (assign != null) ? assign.adoptChildren(typeNode) : typeNode;
                        :}
                        | buildtype:type ID:id builddecla:decla
                        {:
                            AbstractNode typeNode = (((IdNode) type).setId(id));

                            if (decla != null) {
                                AbstractNode assign = decla.getNodes()[0];
                                AbstractNode chain = decla.getNodes()[1];

                                assign.adoptChildren(typeNode);

                                if (chain != null) {
                                    chain.adoptChildren(assign);

                                    RESULT = chain;
                                } else {
                                    RESULT = assign;
                                }
                            } else {
                                RESULT = typeNode;
                            }
                        :}
                        ;

builddecla              ::= buildassign:assign declstoporstay:chain
                        {: RESULT = new StorageNode(assign, chain); :}
                        |
                        ;

blueprintassign         ::= ASSIGN DRAW idpar:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        ;
sizeassign              ::= ASSIGN sizepar:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        ;
gateassign              ::= ASSIGN gateelementspar:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        ;
buildassign             ::= ASSIGN buildelement:elem
                        {: RESULT = new AssignNode().adoptChildren(elem); :}
                        ;
blueprintassignopt      ::= blueprintassign:assign
                        {: RESULT = assign; :}
                        |
                        ;
sizeassignopt           ::= sizeassign:assign
                        {: RESULT = assign; :}
                        |
                        ;
gateassignopt           ::= gateassign:assign
                        {: RESULT = assign; :}
                        |
                        ;

builddeclaration	    ::= BUILD ID:id LPAR elementliststart:elemlist RPAR
                        {:
                            AbstractNode buildNode = new BuildNode(id);
                            RESULT = (elemlist != null) ? buildNode.adoptChildren((new ParamsNode()).adoptChildren(elemlist)) : buildNode;
                        :}
                        ;
declstoporstay		    ::= chain:chain
                        {: RESULT = chain; :}
					    |
                        ;
// ELEMENTLIST
elementliststart	    ::= elementpar:elem elementlistext:next
                        {: RESULT = (next != null) ? next.makeSibling(elem) : elem; :}
					    |
                        ;
elementlist		        ::= elementext:elem elementlistext:next
                        {: RESULT = (next != null) ? next.makeSibling(elem) : elem; :}
                        ;
elementlistext	        ::= elementlist:elemlist
                        {: RESULT = elemlist; :}
					    |
                        ;
elementext		        ::= COMMA elementpar:elem
                        {: RESULT = elem; :}
                        ;

// PROCEDURES
procedures		        ::= PROCEDURE ID:id LPAR pparams:params RPAR LCURLY content:ct RCURLY procedures:next
                        {:
                            AbstractNode procedure = new ProcedureNode(id);
                            if (params != null) {
                                procedure.adoptChildren(new ParamsNode().adoptChildren(params));
                            }
                            procedure.adoptChildren(ct);

                            RESULT = (next != null) ? next.makeSibling(procedure) : procedure;
                        :}
					    |
                        ;
pparams			        ::= type:type ID:id pextparams:next
                        {:
                            AbstractNode param = ((IdNode) type).setId(id);

                            RESULT = (next != null) ? next.makeSibling(param) : param;
                         :}
					    |
                        ;
pextparams		        ::= COMMA pparams:par
                        {: RESULT = par; :}
					    |
                        ;