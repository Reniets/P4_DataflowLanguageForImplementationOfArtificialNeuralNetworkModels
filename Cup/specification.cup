import AST.*;
import java.io.*;
import java_cup.runtime.*;
import java.util.*;

import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

parser code {:

        /*
        public void syntax_error(Symbol cur_token){
            if (!MainParse.isTest) {
                super.syntax_error(cur_token);
            }
        }

        public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
            if (!MainParse.isTest) {
                super.unrecovered_syntax_error(cur_token);
            }

            throw new Exception("Could not recover");
        }
        */

        public static void newScope(){
    	    typenames.push(new HashSet<String>());
        }

        public static void deleteScope(){
    	    typenames.pop();
        }

        public static boolean lookupType(String name){
    	for (HashSet<String> scope: typenames)
    	    if (scope.contains(name)) return true;
    	return false;
        }

        public static void addType(String name){
    	typenames.peek().add(name);
        }

        public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();

        public Parser(Lexer lex, ComplexSymbolFactory sf) {
    	    super(lex,sf);
        }

        class TemporaryNode extends AbstractNode {

             private String s;

             public TemporaryNode(String s) {
               this.s = s;
             }

             public String getName() { return s; }

       }

      //public AbstractNode makeNode(Symbol s) { return new TemporaryNode(symString.symToString[s.sym]); }
      public AbstractNode makeNode(String s) { return new TemporaryNode(s);   }

      //public AbstractNode makeNode(Integer i) { return new IntegerNode(i);   }

:};

// TODO:  Fix dot and add size

/* separators */
terminal Symbol COMMA, SEMICOLON, LPAR, RPAR, LCURLY, RCURLY, ASSIGN, CONNECTION, LSQR, RSQR, DOT;

/* keywords */
terminal Symbol BLOCK, BLUEPRINT, BUILD, DRAW, SOURCE, OPERATION, GATEIN, GATEOUT, PROCEDURE, THIS, SIZE;

/* others */
terminal String ID;
terminal Integer NUMCONST;
terminal SIZECONST;

non terminal AbstractNode block, blocks, prog, type, buildtype, bluetype, gate, blueparam, blueparams,
             content, blueextparams, statement, declaration, declstoporstay, optidstatement, optlparstatement, optthisstatement,
             elementrest, chain, elementliststart, procedurecall, element, groupcon, dotid, elementpar, chainext, parchain,
             elementlist, idassign, elementlistext, elementext, pparams, pextparams, parclosestatement, builddeclaration,
             buildelement, buildelementpar, sizepar, ingatedeclaration, outgatedeclaration, inoutgatedeclaration;

non terminal StorageNode definition, gatedeclarations, blueprint, procedures;

// TODO: Add precedence and associativity

/* The grammar rules */
start with prog;

prog                    ::= blocks:bs
                        {:
                         AbstractNode prog = makeNode("Program").adoptChildren(bs);

                         System.out.println("\nAST\n");
                         prog.walkTree(new PrintTree(System.out));
                        :}
                        ;

// BLOCK
block 			        ::= BLOCK ID:ident LCURLY definition:d RCURLY
                        {:
                            RESULT = new BlockNode(ident).adoptChildren(d.getNodes()[0].getNodes());
                        :}
                        ;

blocks                  ::= block:b
                        {: RESULT = b; :}
                        | block:b blocks:bs
                        {: RESULT = bs.makeSibling(b); :}
                        ;

definition 		        ::=  gatedeclarations:gds blueprint:bp procedures:pds
                        {:
                            RESULT = new StorageNode(gds, bp, pds);
                        :}
                        ;

// GENERAL
type				    ::= buildtype
					    | bluetype
					    | gate
                        ;
buildtype			    ::= BLOCK
					    | OPERATION
					    | SOURCE
                        ;
// GATES
gatedeclarations        ::= ingatedeclaration:ind outgatedeclaration:outd inoutgatedeclaration:inoutd
                        {: RESULT = new StorageNode(ind, outd, inoutd); :}
                        ;
ingatedeclaration       ::= GATEIN ID:id SEMICOLON ingatedeclaration:ind
                        {: RESULT = (ind!=null) ? ind.makeSibling(new InGateNode(id)) : new InGateNode(id); :}
                        |
                        ;
outgatedeclaration      ::= GATEOUT ID:id SEMICOLON
                        ;
inoutgatedeclaration    ::= gate:g ID:id SEMICOLON inoutgatedeclaration:gd
					    |
					    ;
gate				    ::= GATEIN
					    | GATEOUT
                        ;
// BLUEPRINT
blueprint			    ::= BLUEPRINT LPAR blueparams:bps RPAR LCURLY content:cnt RCURLY
                        ;
blueparams		        ::= blueparam
					    |
                        ;
blueparam			    ::= bluetype:bt ID:id blueextparams
                        ;
blueextparams		    ::= COMMA blueparam
                        |
                        ;
// TODO: Add when ready:
bluetype 			    ::= BLUEPRINT
                        | SIZE:s
                        {::}
                        ;
// CONTENT
content			        ::= statement SEMICOLON content
					    |
                        ;
statement			    ::= declaration declstoporstay
					    | ID optidstatement
					    | LPAR optlparstatement
					    |	THIS DOT ID optthisstatement declstoporstay
					    | elementrest chain
					    |
                        ;
procedurecall		    ::= LPAR elementliststart RPAR
                        ;
// OPTION SELECT FOR STATEMENTS
optlparstatement	    ::= LPAR element RPAR groupcon
					    | element parclosestatement
                        ;
parclosestatement	    ::= parchain
					    | groupcon
                        ;
optidstatement	        ::= dotid chain
					    | procedurecall
					    | ASSIGN elementpar declstoporstay
                        ;
optthisstatement	    ::= procedurecall
					    |
                        ;
// COLLECTIVE STATEMENTS
chain				    ::= CONNECTION elementpar chainext
                        ;
parchain			    ::= RPAR CONNECTION elementpar chainext
                        ;
chainext			    ::= CONNECTION elementpar chainext
					    |
                        ;
groupcon			    ::= elementlist RPAR CONNECTION elementpar chainext
                        ;
// ELEMENTS
element			        ::= elementrest
					    | declaration
					    | ID dotid
					    | THIS DOT ID
                        ;
elementrest		        ::= builddeclaration
					    | DRAW ID
					    | SIZECONST
                        ;
buildelement		    ::= builddeclaration
					    | ID
					    | LPAR buildelementpar
					    ;
buildelementpar		    ::= builddeclaration RPAR
					    | ID RPAR
					    ;
dotid				    ::= DOT ID
					    |
                        ;
elementpar		        ::= LPAR element RPAR
					    | element
                        ;

sizepar                 ::= SIZECONST
                        | LPAR SIZECONST RPAR
                        ;
// DECLARATION ELEMENT
declaration		        ::= buildtype idassign buildelement
					    | buildtype ID SEMICOLON
					    | BLUEPRINT idassign DRAW elementpar
					    | gate idassign elementpar
					    | SIZE idassign sizepar
                        ;
builddeclaration	    ::= BUILD ID LPAR elementliststart RPAR
                        ;
idassign			    ::= ID ASSIGN
                        ;
declstoporstay		    ::= chain
					    |
                        ;
// ELEMENTLIST
elementliststart	    ::= elementpar elementlistext
					    |
                        ;
elementlist		        ::= elementext elementlistext
                        ;
elementlistext	        ::= elementlist
					    |
                        ;
elementext		        ::= COMMA elementpar
                        ;
// PROCEDURES
procedures		        ::= PROCEDURE ID LPAR pparams RPAR LCURLY content RCURLY procedures
					    |
                        ;
pparams			        ::= type ID pextparams
					    |
                        ;
pextparams		        ::= COMMA pparams
					    |
                        ;