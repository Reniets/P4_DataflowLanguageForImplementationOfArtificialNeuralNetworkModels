import AST.*;
import java.io.*;
import java_cup.runtime.*;
import java.util.*;

import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

parser code {:

        /*
        public void syntax_error(Symbol cur_token){
            if (!MainParse.isTest) {
                super.syntax_error(cur_token);
            }
        }

        public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
            if (!MainParse.isTest) {
                super.unrecovered_syntax_error(cur_token);
            }

            throw new Exception("Could not recover");
        }
        */

        public static void newScope(){
    	    typenames.push(new HashSet<String>());
        }

        public static void deleteScope(){
    	    typenames.pop();
        }

        public static boolean lookupType(String name){
    	for (HashSet<String> scope: typenames)
    	    if (scope.contains(name)) return true;
    	return false;
        }

        public static void addType(String name){
    	typenames.peek().add(name);
        }

        public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();

        public Parser(Lexer lex, ComplexSymbolFactory sf) {
    	    super(lex,sf);
        }

        class TemporaryNode extends AbstractNode {

             private String s;

             public TemporaryNode(String s) {
               this.s = s;
             }

             public String getName() { return s; }

       }

      //public AbstractNode makeNode(Symbol s) { return new TemporaryNode(symString.symToString[s.sym]); }
      public AbstractNode makeNode(String s) { return new TemporaryNode(s);   }

      //public AbstractNode makeNode(Integer i) { return new IntegerNode(i);   }

:};

// TODO:  Fix dot and add size

/* separators */
terminal Symbol COMMA, SEMICOLON, LPAR, RPAR, LCURLY, RCURLY, ASSIGN, CONNECTION, LSQR, RSQR, DOT;

/* keywords */
terminal Symbol BLOCK, BLUEPRINT, BUILD, DRAW, SOURCE, OPERATION, GATEIN, GATEOUT, PROCEDURE, THIS, SIZE;

/* others */
terminal String ID;
terminal Integer NUMCONST;

non terminal AbstractNode block, blocks, prog, type, buildtype, bluetype, gate, blueparam, blueparams,
             blueextparams, statement, declaration, declstoporstay, optidstatement, optlparstatement, optthisstatement,
             elementrest, chain, elementliststart, procedurecall, element, groupcon, dotid, elementpar, chainext, parchain,
             elementlist, idassign, elementlistext, elementext, pparams, pextparams, parclosestatement, builddeclaration,
             buildelement, buildelementpar, sizepar, sizeconst, ingatedeclaration, outgatedeclaration, inoutgatedeclaration;

non terminal AbstractNode blueprint;

non terminal StorageNode definition, gatedeclarations, procedures;

non terminal DoublePair sizeconst;
// TODO: Add precedence and associativity

/* The grammar rules */
start with prog;

prog                    ::= blocks:bs
                        {:
                         AbstractNode prog = makeNode("Program").adoptChildren(bs);

                         System.out.println("\nAST\n");
                         prog.walkTree(new PrintTree(System.out));
                        :}
                        ;

// BLOCK
block 			        ::= BLOCK ID:ident LCURLY definition:d RCURLY
                        {:
                            RESULT = new BlockNode(ident)
                                            .adoptChildren(d.getNodes()[0].getNodes())  // GateDeclarations (Multiple)
                                            .adoptChildren(d.getNodes()[1]);             // Blueprint        (Single)
                                            //.adoptChildren(d.getNodes()[2].getNodes()); // Procedures       (Multiple)
                        :}
                        ;

blocks                  ::= block:b
                        {: RESULT = b; :}
                        | block:b blocks:bs
                        {: RESULT = bs.makeSibling(b); :}
                        ;

definition 		        ::=  gatedeclarations:gds blueprint:bp procedures:pds
                        {:
                            RESULT = new StorageNode(gds, bp, pds);
                        :}
                        ;

// GENERAL
type				    ::= buildtype
					    | bluetype
					    | gate
                        ;
buildtype			    ::= BLOCK
					    | OPERATION
					    | SOURCE
                        ;
// GATES
gatedeclarations        ::= ingatedeclaration:ind outgatedeclaration:outd inoutgatedeclaration:inoutd
                        {: RESULT = new StorageNode(ind, outd, inoutd); :}
                        ;
ingatedeclaration       ::= GATEIN ID:id SEMICOLON ingatedeclaration:ind
                        {: RESULT = (ind!=null) ? ind.makeSibling(new InGateNode(id)) : new InGateNode(id); :}
                        |
                        ;
outgatedeclaration      ::= GATEOUT ID:id SEMICOLON
                        {: RESULT = new OutGateNode(id); :}
                        ;
inoutgatedeclaration    ::= gate:g ID:id SEMICOLON inoutgatedeclaration:gd
                        {:
                           AbstractNode gateNode = ((TypeNode) g).setId(id);
                           RESULT = (gd != null) ? gd.makeSibling(gateNode) :  gateNode; :}
					    |
					    ;
gate				    ::= GATEIN
                        {: RESULT = new InGateNode("NoIden"); :}
					    | GATEOUT
					    {: RESULT = new OutGateNode("NoIden"); :}
                        ;
// BLUEPRINT
blueprint			    ::= BLUEPRINT LPAR blueparams:bps RPAR LCURLY content:cnt RCURLY
                        {:
                           AbstractNode blueprintNode = new BlueprintNode();
                           if (bps != null) {
                                blueprintNode.adoptChildren(bps);
                           }
                           if (cnt != null) {
                               blueprintNode.adoptChildren(cnt);
                           }
                           RESULT = blueprintNode;
                        :}
                        ;
blueparams		        ::= blueparam:bp
                        {: RESULT = ((new ParamsNode()).adoptChildren(bp)); :}
					    |
                        ;
blueparam			    ::= bluetype:bt ID:id blueextparams:btx
                        {:
                           AbstractNode typeNode = ((TypeNode) bt).setId(id);
                           RESULT = (btx != null) ? (btx.makeSibling(typeNode)) : (typeNode);
                        :}
                        ;
blueextparams		    ::= COMMA blueparam:bp
                        {: RESULT = bp;:}
                        |
                        ;
// TODO: Add when ready:
bluetype 			    ::= BLUEPRINT
                        {: RESULT = new BlueprintTypeNode("NoIden"); :}
                        | SIZE
                        {: RESULT = new SizeNode("NoIden"); :}
                        ;
// CONTENT
content			        ::= statement:st SEMICOLON content:ct
                        {: // TODO: Fix this future me. (Expand to if else chain)
                           RESULT = (st != null && ct != null) ? ct.makeSibling(st) : ((st != null) ? (st) : (ct)); :}
					    |
                        ;
statement			    ::= declaration declstoporstay
					    | ID:id optidstatement
					    {: RESULT = new TemporaryNode("ID optID " + id); :}
					    | LPAR optlparstatement
					    | THIS DOT ID optthisstatement
					    | elementrest chain
					    |
                        ;
procedurecall		    ::= LPAR elementliststart RPAR
                        ;
// OPTION SELECT FOR STATEMENTS
optlparstatement	    ::= LPAR element RPAR groupcon
					    | element parclosestatement
                        ;
parclosestatement	    ::= parchain
					    | groupcon
                        ;
optidstatement	        ::= dotid chain
					    | procedurecall
					    | ASSIGN elementpar declstoporstay
                        ;
optthisstatement	    ::= procedurecall
                        | declstoporstay
                        ;
// COLLECTIVE STATEMENTS
chain				    ::= CONNECTION elementpar chainext
                        ;
parchain			    ::= RPAR CONNECTION elementpar chainext
                        ;
chainext			    ::= CONNECTION elementpar chainext
					    |
                        ;
groupcon			    ::= elementlist RPAR CONNECTION elementpar chainext
                        ;
// ELEMENTS
element			        ::= elementrest
					    | declaration
					    | ID dotid
					    | THIS DOT ID
                        ;
elementrest		        ::= builddeclaration
					    | DRAW ID
					    | sizeconst
                        ;
buildelement		    ::= builddeclaration
					    | ID
					    | LPAR buildelementpar
					    ;
buildelementpar		    ::= builddeclaration RPAR
					    | ID RPAR
					    ;
dotid				    ::= DOT ID
					    |
                        ;
elementpar		        ::= LPAR element RPAR
					    | element
                        ;

sizepar                 ::= sizeconst
                        | LPAR sizeconst RPAR
                        ;

sizeconst               ::= LSQR NUMCONST:n1 COMMA NUMCONST:n2 RSQR
                        {: RESULT = new DoublePair(n1, n2); :}
                        ;
// DECLARATION ELEMENT
declaration		        ::= buildtype idassign buildelement
					    | buildtype ID SEMICOLON
					    | BLUEPRINT idassign DRAW elementpar
					    | gate idassign elementpar
					    | SIZE idassign sizepar
                        ;
builddeclaration	    ::= BUILD ID LPAR elementliststart RPAR
                        ;
idassign			    ::= ID ASSIGN
                        ;
declstoporstay		    ::= chain
					    |
                        ;
// ELEMENTLIST
elementliststart	    ::= elementpar elementlistext
					    |
                        ;
elementlist		        ::= elementext elementlistext
                        ;
elementlistext	        ::= elementlist
					    |
                        ;
elementext		        ::= COMMA elementpar
                        ;
// PROCEDURES
procedures		        ::= PROCEDURE ID LPAR pparams RPAR LCURLY content RCURLY procedures
					    |
                        ;
pparams			        ::= type ID pextparams
					    |
                        ;
pextparams		        ::= COMMA pparams
					    |
                        ;