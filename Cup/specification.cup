import AST.*;
import java.io.*;
import java_cup.runtime.*;
import java.util.*;

import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;

parser code {:

        /*
        public void syntax_error(Symbol cur_token){
            if (!MainParse.isTest) {
                super.syntax_error(cur_token);
            }
        }
        */

        // ##### IMPORTANT IMPLEMENTATION - THE "ScannerException" CLASS IS USED IN TESTING!!! #####
        public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
            try {
                // Call original method implementation
                super.unrecovered_syntax_error(cur_token);
            } catch (Exception e) {
                // Rethrow exception as a ScannerException instead of a generic "Exception", to identify in testing.
                throw new AutoGen.ScannerException(e);
            }
        }

        public static void newScope(){
    	    typenames.push(new HashSet<String>());
        }

        public static void deleteScope(){
    	    typenames.pop();
        }

        public static boolean lookupType(String name){
    	for (HashSet<String> scope: typenames)
    	    if (scope.contains(name)) return true;
    	return false;
        }

        public static void addType(String name){
    	typenames.peek().add(name);
        }

        public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();

        public Parser(Lexer lex, ComplexSymbolFactory sf) {
    	    super(lex,sf);
        }

        class TemporaryNode extends AbstractNode {

             private String s;

             public TemporaryNode(String s) {
               this.s = s;
             }

             public String getName() { return s; }

       }

      //public AbstractNode makeNode(Symbol s) { return new TemporaryNode(symString.symToString[s.sym]); }
      public AbstractNode makeNode(String s) { return new TemporaryNode(s);   }

      //public AbstractNode makeNode(Integer i) { return new IntegerNode(i);   }

:};

// TODO:  Fix dot and add size

/* separators */
terminal Symbol COMMA, SEMICOLON, LPAR, RPAR, LCURLY, RCURLY, ASSIGN, CONNECTION, LSQR, RSQR, DOT;

/* keywords */
terminal Symbol BLOCK, BLUEPRINT, BUILD, DRAW, SOURCE, OPERATION, GATEIN, GATEOUT, PROCEDURE, THIS, SIZE;

/* others */
terminal String ID;
terminal Double NUMCONST;
terminal Integer INTCONST;

non terminal AbstractNode block, blocks, prog, type, buildtype, bluetype, gate, blueparam, blueparams,
             blueextparams, statement, declaration, declstoporstay, optidstatement, optlparstatement, optthisstatement,
             elementrest, chain, elementliststart, procedurecall, element, groupcon, dotid, elementpar, chainext, parchain,
             elementlist, idassign, elementlistext, elementext, pparams, pextparams, parclosestatement, builddeclaration,
             buildelement, buildelementpar, sizepar, ingatedeclaration, outgatedeclaration, inoutgatedeclaration,
             emptydeclaration, fulldeclaration, nodedeclaration, nonnodedeclaration, nodeelement, nonnodeelement, nodeelementpar;

non terminal AbstractNode blueprint, content, procedures;

non terminal StorageNode definition, gatedeclarations;

non terminal DoublePair sizeconst;
// TODO: Add precedence and associativity

/* The grammar rules */
start with prog;

prog                    ::= blocks:bs
                        {:
                         AbstractNode prog = makeNode("Program").adoptChildren(bs);

                         System.out.println("\nAST\n");
                         prog.walkTree(new PrintTree(System.out));
                        :}
                        ;

// BLOCK
block 			        ::= BLOCK ID:ident LCURLY definition:d RCURLY
                        {:
                            RESULT = new BlockNode(ident)
                                            .adoptChildren(d.getNodes()[0].getNodes())  // GateDeclarations (Multiple)
                                            .adoptChildren(d.getNodes()[1])             // Blueprint        (Single)
                                            .adoptChildren(d.getNodes()[2]);            // Procedures       (Multiple singles)
                        :}
                        ;

blocks                  ::= block:b
                        {: RESULT = b; :}
                        | block:b blocks:bs
                        {: RESULT = bs.makeSibling(b); :}
                        ;

definition 		        ::=  gatedeclarations:gds blueprint:bp procedures:pds
                        {:
                            RESULT = new StorageNode(gds, bp, pds);
                        :}
                        ;

// GENERAL
type				    ::= buildtype:type
                        {: RESULT = type; :}
					    | bluetype:type
					    {: RESULT = type; :}
					    | gate:gate
					    {: RESULT = gate; :}
                        ;
buildtype			    ::= BLOCK
                        {: RESULT = new BlockTypeNode("NoIden"); :}
					    | OPERATION
					    {: RESULT = new OperationTypeNode("NoIden"); :}
					    | SOURCE
					    {: RESULT = new SourceTypeNode("NoIden"); :}
                        ;
// GATES
gatedeclarations        ::= ingatedeclaration:ind outgatedeclaration:outd inoutgatedeclaration:inoutd
                        {: RESULT = new StorageNode(ind, outd, inoutd); :}
                        ;
ingatedeclaration       ::= GATEIN ID:id SEMICOLON ingatedeclaration:ind
                        {: RESULT = (ind!=null) ? ind.makeSibling(new InGateNode(id)) : new InGateNode(id); :}
                        |
                        ;
outgatedeclaration      ::= GATEOUT ID:id SEMICOLON
                        {: RESULT = new OutGateNode(id); :}
                        ;
inoutgatedeclaration    ::= gate:g ID:id SEMICOLON inoutgatedeclaration:gd
                        {:
                           AbstractNode gateNode = ((IdNode) g).setId(id);
                           RESULT = (gd != null) ? gd.makeSibling(gateNode) :  gateNode; :}
					    |
					    ;
gate				    ::= GATEIN
                        {: RESULT = new InGateNode("NoIden"); :}
					    | GATEOUT
					    {: RESULT = new OutGateNode("NoIden"); :}
                        ;
// BLUEPRINT
blueprint			    ::= BLUEPRINT LPAR blueparams:bps RPAR LCURLY content:cnt RCURLY
                        {:
                           AbstractNode blueprintNode = new BlueprintNode();
                           if (bps != null) {
                                blueprintNode.adoptChildren(bps);
                           }
                           if (cnt != null) {
                               blueprintNode.adoptChildren(cnt);
                           }
                           RESULT = blueprintNode;
                        :}
                        ;
blueparams		        ::= blueparam:bp
                        {: RESULT = ((new ParamsNode()).adoptChildren(bp)); :}
					    |
                        ;
blueparam			    ::= bluetype:bt ID:id blueextparams:btx
                        {:
                           AbstractNode typeNode = ((IdNode) bt).setId(id);
                           RESULT = (btx != null) ? (btx.makeSibling(typeNode)) : (typeNode);
                        :}
                        ;
blueextparams		    ::= COMMA blueparam:bp
                        {: RESULT = bp;:}
                        |
                        ;
// TODO: Add when ready:
bluetype 			    ::= BLUEPRINT
                        {: RESULT = new BlueprintTypeNode("NoIden"); :}
                        | SIZE
                        {: RESULT = new SizeNode("NoIden"); :}
                        ;
// CONTENT
content			        ::= statement:st SEMICOLON content:ct
                        {: // TODO: Fix this future me. (Expand to if else chain)
                           RESULT = (st != null && ct != null) ? ct.makeSibling(st) : ((st != null) ? (st) : (ct)); :}
					    |
                        ;
statement			    ::= emptydeclaration
                        | nonnodedeclaration
                        | nodedeclaration declstoporstay
					    | ID:id optidstatement:st
					    {:
					        // Chain
					        if (st instanceof StorageNode) {
					            String storageName = st.getName();

					            if ("Chain".equals(storageName)) {
					                AbstractNode chainNode = st.getNodes()[1];
                                    AbstractNode idSelector = new SelectorNode(id, false);

                                    idSelector.adoptChildren(st.getNodes()[0]);

                                    RESULT = chainNode.adoptChildren(idSelector);
					            } else if ("Assign".equals(storageName)) {
					                AbstractNode assignNode = st.getNodes()[0].adoptChildren(new SelectorNode(id, false));
					                AbstractNode chainNode = st.getNodes()[1];

					                RESULT = (chainNode != null) ? chainNode.adoptChildren(assignNode) : assignNode;

					            } else {
					                // Security check, should never happen - But helps with development.
					                throw new RuntimeException("No such name case");
					            }
					        } else {
					            RESULT = st.adoptChildren(new SelectorNode(id, false));
					        }
					    :}
					    | LPAR optlparstatement
					    | THIS DOT ID:id optthisstatement:st
					    {: RESULT = st.adoptChildren(new SelectorNode(id, true)); :}
					    | builddeclaration chain
					    |
                        ;
procedurecall		    ::= LPAR elementliststart:paras RPAR
                        {:
                            AbstractNode procedure = new ProcedureCallNode();

                            if (paras != null) {
                                procedure.adoptChildren((new ParamsNode()).adoptChildren(paras));
                            }

                            RESULT = procedure;
                        :}
                        ;
// OPTION SELECT FOR STATEMENTS
optlparstatement	    ::= LPAR element RPAR groupcon
					    | element parclosestatement
                        ;
parclosestatement	    ::= parchain
					    | groupcon
                        ;
optidstatement	        ::= dotid:did chain:c
                        {: RESULT = new StorageNode("Chain", did, c); :}
					    | procedurecall:pdc
					    {: RESULT = pdc; :}
					    | ASSIGN elementpar:elem declstoporstay:chain
					    {: RESULT = new StorageNode("Assign", new AssignNode().adoptChildren(elem), chain); :}
                        ;
optthisstatement	    ::= procedurecall:pdc
                        {: RESULT = pdc; :}
                        | chain:chain
                        {: RESULT = chain; :}
                        ;
// COLLECTIVE STATEMENTS
chain				    ::= CONNECTION nodeelementpar:elem chainext:next
                        {:
                            RESULT = (next != null) ? next.adoptChildren(elem) : new ChainNode().adoptChildren(elem);
                         :}
                        ;
parchain			    ::= RPAR chain:chain
                        {: RESULT = chain; :}
                        ;
chainext			    ::= chain:chain
                        {: RESULT = chain; :}
					    |
                        ;
groupcon			    ::= elementlist RPAR CONNECTION elementpar chainext
                        ;
// ELEMENTS
element			        ::= elementrest:elem
                        {: RESULT = elem; :}
					    | nodeelement:elem
					    {: RESULT = elem; :}
					    | nonnodeelement:elem
					    {: RESULT = elem; :}
					    | nonnodedeclaration:elem
					    {: RESULT = elem; :}
                        ;

nodeelement             ::= nodedeclaration:elem
                        {: RESULT = elem; :}
                        | ID:id dotid:did
                        {: RESULT = (new SelectorNode(id, false)).adoptChildren(did); :}
                        | THIS DOT ID:id
                        {: RESULT = new SelectorNode(id, true); :}
                        | builddeclaration:build
                        {: RESULT = build; :}
                        ;

nonnodeelement          ::= DRAW ID:id
                        {: RESULT = new DrawNode(id); :}
                        | sizeconst:sc
                        {: RESULT = sc; :}
                        ;

buildelement		    ::= builddeclaration:build
                        {: RESULT = build; :}
					    | ID:id
					    {: RESULT = new SelectorNode(id, false); :}
					    | LPAR buildelementpar:belem
					    {: RESULT = belem; :}
					    ;
buildelementpar		    ::= builddeclaration:build RPAR
                        {: RESULT = build; :}
					    | ID:id RPAR
                        {: RESULT = new SelectorNode(id, false); :}
					    ;
dotid				    ::= DOT ID:id
                        {: RESULT = new SelectorNode(id, false); :}
					    |
                        ;
elementpar		        ::= LPAR element:elem RPAR
                        {: RESULT = elem; :}
					    | element:elem
					    {: RESULT = elem; :}
                        ;

nodeelementpar          ::= LPAR nodeelement:elem RPAR
                        {: RESULT = elem; :}
                        | nodeelement:elem
                        {: RESULT = elem; :}
                        ;

sizepar                 ::= sizeconst
                        | LPAR sizeconst RPAR
                        ;

sizeconst               ::= LSQR INTCONST:n1 COMMA INTCONST:n2 RSQR
                        {: RESULT = new DoublePair(n1, n2); :}
                        ;
// DECLARATION ELEMENT
nodedeclaration         ::= buildtype idassign buildelement
                        ;

nonnodedeclaration      ::= gate idassign elementpar
                        | SIZE idassign sizepar
                        | BLUEPRINT idassign DRAW elementpar
                        ;

blueprintassign         ::= ASSIGN DRAW elementpar
                        |
                        ;

emptydeclaration        ::= type ID
                        ;

builddeclaration	    ::= BUILD ID:id LPAR elementliststart:elemlist RPAR
                        {: RESULT = new BuildNode(id).adoptChildren((new ParamsNode()).adoptChildren(elemlist)); :}
                        ;
idassign			    ::= ID ASSIGN
                        ;
declstoporstay		    ::= chain
					    |
                        ;
// ELEMENTLIST
elementliststart	    ::= elementpar:elem elementlistext:next
                        {: RESULT = (next != null) ? next.makeSibling(elem) : elem; :}
					    |
                        ;
elementlist		        ::= elementext:elem elementlistext:next
                        {: RESULT = (next != null) ? next.makeSibling(elem) : elem; :}
                        ;
elementlistext	        ::= elementlist:elemlist
                        {: RESULT = elemlist; :}
					    |
                        ;
elementext		        ::= COMMA elementpar:elem
                        {: RESULT = elem; :}
                        ;
// PROCEDURES
procedures		        ::= PROCEDURE ID:id LPAR pparams:params RPAR LCURLY content:ct RCURLY procedures:next
                        {:
                            AbstractNode procedure = new ProcedureNode(id);
                            if (params != null) {
                                procedure.adoptChildren(new ParamsNode().adoptChildren(params));
                            }
                            procedure.adoptChildren(ct);

                            RESULT = (next != null) ? next.makeSibling(procedure) : procedure;
                        :}
					    |
                        ;
pparams			        ::= type:type ID:id pextparams:next
                        {:
                            AbstractNode param = ((IdNode) type).setId(id);

                            RESULT = (next != null) ? next.makeSibling(param) : param;
                         :}
					    |
                        ;
pextparams		        ::= COMMA pparams:par
                        {: RESULT = par; :}
					    |
                        ;